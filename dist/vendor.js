!function(n){function e(e){for(var r,o,f=e[0],s=e[1],u=e[2],d=0,h=[];d<f.length;d++)o=f[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&h.push(i[o][0]),i[o]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(l&&l(e);h.length;)h.shift()();return a.push.apply(a,u||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,f=1;f<t.length;f++){var s=t[f];0!==i[s]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={vendor:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="";var f=window.webpackJsonp=window.webpackJsonp||[],s=f.push.bind(f);f.push=e,f=f.slice();for(var u=0;u<f.length;u++)e(f[u]);var l=s;a.push([0,"app~vendor"]),t()}({"./lib/Cesium/Sandcastle/Sandcastle-header.js":
/*!****************************************************!*\
  !*** ./lib/Cesium/Sandcastle/Sandcastle-header.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n(function () {\n    'use strict';\n\n    var defaultAction;\n    var bucket = window.location.href;\n    var pos = bucket.lastIndexOf('/');\n    if (pos > 0 && pos < bucket.length - 1) {\n        bucket = bucket.substring(pos + 1);\n    }\n\n    window.Sandcastle = {\n        bucket: bucket,\n        declare: function declare() {},\n        highlight: function highlight() {},\n        registered: [],\n        finishedLoading: function finishedLoading() {\n            window.Sandcastle.reset();\n\n            if (defaultAction) {\n                window.Sandcastle.highlight(defaultAction);\n                defaultAction();\n                defaultAction = undefined;\n            }\n\n            document.body.className = document.body.className.replace(/(?:\\s|^)sandcastle-loading(?:\\s|$)/, ' ');\n        },\n        addToggleButton: function addToggleButton(text, checked, onchange, toolbarID) {\n            window.Sandcastle.declare(onchange);\n            var input = document.createElement('input');\n            input.checked = checked;\n            input.type = 'checkbox';\n            input.style.pointerEvents = 'none';\n            var label = document.createElement('label');\n            label.appendChild(input);\n            label.appendChild(document.createTextNode(text));\n            label.style.pointerEvents = 'none';\n            var button = document.createElement('button');\n            button.type = 'button';\n            button.className = 'cesium-button';\n            button.appendChild(label);\n\n            button.onclick = function () {\n                window.Sandcastle.reset();\n                window.Sandcastle.highlight(onchange);\n                input.checked = !input.checked;\n                onchange(input.checked);\n            };\n\n            document.getElementById(toolbarID || 'toolbar').appendChild(button);\n        },\n        addToolbarButton: function addToolbarButton(text, onclick, toolbarID) {\n            window.Sandcastle.declare(onclick);\n            var button = document.createElement('button');\n            button.type = 'button';\n            button.className = 'cesium-button';\n            button.onclick = function () {\n                window.Sandcastle.reset();\n                window.Sandcastle.highlight(onclick);\n                onclick();\n            };\n            button.textContent = text;\n            document.getElementById(toolbarID || 'toolbar').appendChild(button);\n        },\n        addDefaultToolbarButton: function addDefaultToolbarButton(text, onclick, toolbarID) {\n            window.Sandcastle.addToolbarButton(text, onclick, toolbarID);\n            defaultAction = onclick;\n        },\n        addDefaultToolbarMenu: function addDefaultToolbarMenu(options, toolbarID) {\n            window.Sandcastle.addToolbarMenu(options, toolbarID);\n            defaultAction = options[0].onselect;\n        },\n        addToolbarMenu: function addToolbarMenu(options, toolbarID) {\n            var menu = document.createElement('select');\n            menu.className = 'cesium-button';\n            menu.onchange = function () {\n                window.Sandcastle.reset();\n                var item = options[menu.selectedIndex];\n                if (item && typeof item.onselect === 'function') {\n                    item.onselect();\n                }\n            };\n            document.getElementById(toolbarID || 'toolbar').appendChild(menu);\n\n            if (!defaultAction && typeof options[0].onselect === 'function') {\n                defaultAction = options[0].onselect;\n            }\n\n            for (var i = 0, len = options.length; i < len; ++i) {\n                var option = document.createElement('option');\n                option.textContent = options[i].text;\n                option.value = options[i].value;\n                menu.appendChild(option);\n            }\n        },\n        reset: function reset() {}\n    };\n\n    if (window.location.protocol === 'file:') {\n        if (window.confirm(\"You must host this app on a web server.\\nSee contributor's guide for more info?\")) {\n            window.location = 'https://github.com/AnalyticalGraphicsInc/cesium/wiki/Contributor%27s-Guide';\n        }\n    }\n})();\n\n//# sourceURL=webpack:///./lib/Cesium/Sandcastle/Sandcastle-header.js?")},"./lib/netcdfjs.js":
/*!*************************!*\
  !*** ./lib/netcdfjs.js ***!
  \*************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * netcdfjs - Read and explore NetCDF files\r\n * @version v0.7.0\r\n * @link https://github.com/cheminfo-js/netcdfjs\r\n * @license MIT\r\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(typeof self !== 'undefined' ? self : undefined, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/function __webpack_require__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/ };\n        /******/\n        /******/ // Execute the module function\n        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/__webpack_require__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/__webpack_require__.c = installedModules;\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/__webpack_require__.d = function (exports, name, getter) {\n        /******/if (!__webpack_require__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, { enumerable: true, get: getter });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // define __esModule on exports\n      /******/__webpack_require__.r = function (exports) {\n        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n          /******/\n        }\n        /******/Object.defineProperty(exports, '__esModule', { value: true });\n        /******/\n      };\n      /******/\n      /******/ // create a fake namespace object\n      /******/ // mode & 1: value is a module id, require it\n      /******/ // mode & 2: merge all properties of value into the ns\n      /******/ // mode & 4: return value when already ns object\n      /******/ // mode & 8|1: behave like require\n      /******/__webpack_require__.t = function (value, mode) {\n        /******/if (mode & 1) value = __webpack_require__(value);\n        /******/if (mode & 8) return value;\n        /******/if (mode & 4 && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value && value.__esModule) return value;\n        /******/var ns = Object.create(null);\n        /******/__webpack_require__.r(ns);\n        /******/Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n        /******/if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        } /******/return ns;\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/__webpack_require__.n = function (module) {\n        /******/var getter = module && module.__esModule ?\n        /******/function getDefault() {\n          return module['default'];\n        } :\n        /******/function getModuleExports() {\n          return module;\n        };\n        /******/__webpack_require__.d(getter, 'a', getter);\n        /******/return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/__webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/__webpack_require__.p = \"\";\n      /******/\n      /******/\n      /******/ // Load entry module and return exports\n      /******/return __webpack_require__(__webpack_require__.s = 3);\n      /******/\n    }(\n    /************************************************************************/\n    /******/[\n    /* 0 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      /**\r\n       * Throws a non-valid NetCDF exception if the statement it's true\r\n       * @ignore\r\n       * @param {boolean} statement - Throws if true\r\n       * @param {string} reason - Reason to throw\r\n       */\n\n      function notNetcdf(statement, reason) {\n        if (statement) {\n          throw new TypeError('Not a valid NetCDF v3.x file: ' + reason);\n        }\n      }\n      /**\r\n       * Moves 1, 2, or 3 bytes to next 4-byte boundary\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       */\n\n      function padding(buffer) {\n        if (buffer.offset % 4 !== 0) {\n          buffer.skip(4 - buffer.offset % 4);\n        }\n      }\n      /**\r\n       * Reads the name\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @return {string} - Name\r\n       */\n\n      function readName(buffer) {\n        // Read name\n        var nameLength = buffer.readUint32();\n        var name = buffer.readChars(nameLength); // validate name\n        // TODO\n        // Apply padding\n\n        padding(buffer);\n        return name;\n      }\n\n      module.exports.notNetcdf = notNetcdf;\n      module.exports.padding = padding;\n      module.exports.readName = readName;\n\n      /***/\n    },\n    /* 1 */\n    /***/function (module, exports) {\n\n      var g; // This works in non-strict mode\n\n      g = function () {\n        return this;\n      }();\n\n      try {\n        // This works if eval is allowed (see CSP)\n        g = g || Function(\"return this\")() || (1, eval)(\"this\");\n      } catch (e) {\n        // This works if the window reference is available\n        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === \"object\") g = window;\n      } // g can still be undefined, but nothing to do about it...\n      // We return undefined, instead of nothing here, so it's\n      // easier to handle this case. if(!global) { ...}\n\n\n      module.exports = g;\n\n      /***/\n    },\n    /* 2 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      var notNetcdf = __webpack_require__(0).notNetcdf;\n\n      var types = {\n        BYTE: 1,\n        CHAR: 2,\n        SHORT: 3,\n        INT: 4,\n        FLOAT: 5,\n        DOUBLE: 6\n      };\n      /**\r\n       * Parse a number into their respective type\r\n       * @ignore\r\n       * @param {number} type - integer that represents the type\r\n       * @return {string} - parsed value of the type\r\n       */\n\n      function num2str(type) {\n        switch (Number(type)) {\n          case types.BYTE:\n            return 'byte';\n\n          case types.CHAR:\n            return 'char';\n\n          case types.SHORT:\n            return 'short';\n\n          case types.INT:\n            return 'int';\n\n          case types.FLOAT:\n            return 'float';\n\n          case types.DOUBLE:\n            return 'double';\n\n          /* istanbul ignore next */\n\n          default:\n            return 'undefined';\n        }\n      }\n      /**\r\n       * Parse a number type identifier to his size in bytes\r\n       * @ignore\r\n       * @param {number} type - integer that represents the type\r\n       * @return {number} -size of the type\r\n       */\n\n      function num2bytes(type) {\n        switch (Number(type)) {\n          case types.BYTE:\n            return 1;\n\n          case types.CHAR:\n            return 1;\n\n          case types.SHORT:\n            return 2;\n\n          case types.INT:\n            return 4;\n\n          case types.FLOAT:\n            return 4;\n\n          case types.DOUBLE:\n            return 8;\n\n          /* istanbul ignore next */\n\n          default:\n            return -1;\n        }\n      }\n      /**\r\n       * Reverse search of num2str\r\n       * @ignore\r\n       * @param {string} type - string that represents the type\r\n       * @return {number} - parsed value of the type\r\n       */\n\n      function str2num(type) {\n        switch (String(type)) {\n          case 'byte':\n            return types.BYTE;\n\n          case 'char':\n            return types.CHAR;\n\n          case 'short':\n            return types.SHORT;\n\n          case 'int':\n            return types.INT;\n\n          case 'float':\n            return types.FLOAT;\n\n          case 'double':\n            return types.DOUBLE;\n\n          /* istanbul ignore next */\n\n          default:\n            return -1;\n        }\n      }\n      /**\r\n       * Auxiliary function to read numeric data\r\n       * @ignore\r\n       * @param {number} size - Size of the element to read\r\n       * @param {function} bufferReader - Function to read next value\r\n       * @return {Array<number>|number}\r\n       */\n\n      function readNumber(size, bufferReader) {\n        if (size !== 1) {\n          var numbers = new Array(size);\n\n          for (var i = 0; i < size; i++) {\n            numbers[i] = bufferReader();\n          }\n\n          return numbers;\n        } else {\n          return bufferReader();\n        }\n      }\n      /**\r\n       * Given a type and a size reads the next element\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @param {number} type - Type of the data to read\r\n       * @param {number} size - Size of the element to read\r\n       * @return {string|Array<number>|number}\r\n       */\n\n      function readType(buffer, type, size) {\n        switch (type) {\n          case types.BYTE:\n            return buffer.readBytes(size);\n\n          case types.CHAR:\n            return trimNull(buffer.readChars(size));\n\n          case types.SHORT:\n            return readNumber(size, buffer.readInt16.bind(buffer));\n\n          case types.INT:\n            return readNumber(size, buffer.readInt32.bind(buffer));\n\n          case types.FLOAT:\n            return readNumber(size, buffer.readFloat32.bind(buffer));\n\n          case types.DOUBLE:\n            return readNumber(size, buffer.readFloat64.bind(buffer));\n\n          /* istanbul ignore next */\n\n          default:\n            notNetcdf(true, 'non valid type ' + type);\n            return undefined;\n        }\n      }\n      /**\r\n       * Removes null terminate value\r\n       * @ignore\r\n       * @param {string} value - String to trim\r\n       * @return {string} - Trimmed string\r\n       */\n\n      function trimNull(value) {\n        if (value.charCodeAt(value.length - 1) === 0) {\n          return value.substring(0, value.length - 1);\n        }\n\n        return value;\n      }\n\n      module.exports = types;\n      module.exports.num2str = num2str;\n      module.exports.num2bytes = num2bytes;\n      module.exports.str2num = str2num;\n      module.exports.readType = readType;\n\n      /***/\n    },\n    /* 3 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      var IOBuffer = __webpack_require__(4);\n\n      var utils = __webpack_require__(0);\n\n      var data = __webpack_require__(11);\n\n      var readHeader = __webpack_require__(12);\n\n      var _toString = __webpack_require__(13);\n      /**\r\n       * Reads a NetCDF v3.x file\r\n       * https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html\r\n       * @param {ArrayBuffer} data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\r\n       * @constructor\r\n       */\n\n      var NetCDFReader = function () {\n        function NetCDFReader(data) {\n          _classCallCheck(this, NetCDFReader);\n\n          var buffer = new IOBuffer(data);\n          buffer.setBigEndian(); // Validate that it's a NetCDF file\n\n          utils.notNetcdf(buffer.readChars(3) !== 'CDF', 'should start with CDF'); // Check the NetCDF format\n\n          var version = buffer.readByte();\n          utils.notNetcdf(version > 2, 'unknown version'); // Read the header\n\n          this.header = readHeader(buffer, version);\n          this.buffer = buffer;\n        }\n        /**\r\n         * @return {string} - Version for the NetCDF format\r\n         */\n\n        _createClass(NetCDFReader, [{\n          key: 'getAttribute',\n\n          /**\r\n           * Returns the value of an attribute\r\n           * @param {string} attributeName\r\n           * @return {string} Value of the attributeName or undefined\r\n           */\n\n          value: function getAttribute(attributeName) {\n            var attribute = this.globalAttributes.find(function (val) {\n              return val.name === attributeName;\n            });\n            if (attribute) return attribute.value.trim();\n            return undefined;\n          }\n          /**\r\n           * Returns the value of a variable as a string\r\n           * @param {string} variableName\r\n           * @return {string} Value of the variable as a string or undefined\r\n           */\n\n        }, {\n          key: 'getDataVariableAsString',\n          value: function getDataVariableAsString(variableName) {\n            try {\n              return this.getDataVariable(variableName).join('').trim();\n            } catch (e) {\n              return undefined;\n            }\n          }\n          /**\r\n           * @return {Array<object>} - List of variables with:\r\n           *  * `name`: String with the name of the variable\r\n           *  * `dimensions`: Array with the dimension IDs of the variable\r\n           *  * `attributes`: Array with the attributes of the variable\r\n           *  * `type`: String with the type of the variable\r\n           *  * `size`: Number with the size of the variable\r\n           *  * `offset`: Number with the offset where of the variable begins\r\n           *  * `record`: True if is a record variable, false otherwise\r\n           */\n\n        }, {\n          key: 'toString',\n          value: function toString() {\n            return _toString.call(this);\n          }\n          /**\r\n           * Retrieves the data for a given variable\r\n           * @param {string|object} variableName - Name of the variable to search or variable object\r\n           * @return {Array} - List with the variable values\r\n           */\n\n        }, {\n          key: 'getDataVariable',\n          value: function getDataVariable(variableName) {\n            var variable;\n\n            if (typeof variableName === 'string') {\n              // search the variable\n              variable = this.header.variables.find(function (val) {\n                return val.name === variableName;\n              });\n            } else {\n              variable = variableName;\n            } // throws if variable not found\n\n\n            utils.notNetcdf(variable === undefined, 'variable not found: ' + variableName); // go to the offset position\n\n            this.buffer.seek(variable.offset);\n\n            if (variable.record) {\n              // record variable case\n              return data.record(this.buffer, variable, this.header.recordDimension);\n            } else {\n              // non-record variable case\n              return data.nonRecord(this.buffer, variable);\n            }\n          }\n          /**\r\n           * Check if a dataVariable exists\r\n           * @param {string} variableName - Name of the variable to find\r\n           * @return {boolean}\r\n           */\n\n        }, {\n          key: 'dataVariableExists',\n          value: function dataVariableExists(variableName) {\n            var variable = this.header.variables.find(function (val) {\n              return val.name === variableName;\n            });\n            return variable !== undefined;\n          }\n          /**\r\n           * Check if an attribute exists\r\n           * @param {string} attributeName - Name of the attribute to find\r\n           * @return {boolean}\r\n           */\n\n        }, {\n          key: 'attributeExists',\n          value: function attributeExists(attributeName) {\n            var attribute = this.globalAttributes.find(function (val) {\n              return val.name === attributeName;\n            });\n            return attribute !== undefined;\n          }\n        }, {\n          key: 'version',\n          get: function get() {\n            if (this.header.version === 1) {\n              return 'classic format';\n            } else {\n              return '64-bit offset format';\n            }\n          }\n          /**\r\n           * @return {object} - Metadata for the record dimension\r\n           *  * `length`: Number of elements in the record dimension\r\n           *  * `id`: Id number in the list of dimensions for the record dimension\r\n           *  * `name`: String with the name of the record dimension\r\n           *  * `recordStep`: Number with the record variables step size\r\n           */\n\n        }, {\n          key: 'recordDimension',\n          get: function get() {\n            return this.header.recordDimension;\n          }\n          /**\r\n           * @return {Array<object>} - List of dimensions with:\r\n           *  * `name`: String with the name of the dimension\r\n           *  * `size`: Number with the size of the dimension\r\n           */\n\n        }, {\n          key: 'dimensions',\n          get: function get() {\n            return this.header.dimensions;\n          }\n          /**\r\n           * @return {Array<object>} - List of global attributes with:\r\n           *  * `name`: String with the name of the attribute\r\n           *  * `type`: String with the type of the attribute\r\n           *  * `value`: A number or string with the value of the attribute\r\n           */\n\n        }, {\n          key: 'globalAttributes',\n          get: function get() {\n            return this.header.globalAttributes;\n          }\n        }, {\n          key: 'variables',\n          get: function get() {\n            return this.header.variables;\n          }\n        }]);\n\n        return NetCDFReader;\n      }();\n\n      module.exports = NetCDFReader;\n\n      /***/\n    },\n    /* 4 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n      (function (Buffer) {\n\n        var utf8 = __webpack_require__(9);\n\n        var defaultByteLength = 1024 * 8;\n        var charArray = [];\n        /**\r\n         * IOBuffer\r\n         * @constructor\r\n         * @param {undefined|number|ArrayBuffer|TypedArray|IOBuffer|Buffer} data - The data to construct the IOBuffer with.\r\n         *\r\n         * If it's a number, it will initialize the buffer with the number as the buffer's length<br>\r\n         * If it's undefined, it will initialize the buffer with a default length of 8 Kb<br>\r\n         * If its an ArrayBuffer, a TypedArray, an IOBuffer instance,\r\n         * or a Node.js Buffer, it will create a view over the underlying ArrayBuffer.\r\n         * @param {object} [options]\r\n         * @param {number} [options.offset=0] - Ignore the first n bytes of the ArrayBuffer\r\n         * @property {ArrayBuffer} buffer - Reference to the internal ArrayBuffer object\r\n         * @property {number} length - Byte length of the internal ArrayBuffer\r\n         * @property {number} offset - The current offset of the buffer's pointer\r\n         * @property {number} byteLength - Byte length of the internal ArrayBuffer\r\n         * @property {number} byteOffset - Byte offset of the internal ArrayBuffer\r\n         */\n\n        var IOBuffer = function () {\n          function IOBuffer(data, options) {\n            _classCallCheck(this, IOBuffer);\n\n            options = options || {};\n            var dataIsGiven = false;\n\n            if (data === undefined) {\n              data = defaultByteLength;\n            }\n\n            if (typeof data === 'number') {\n              data = new ArrayBuffer(data);\n            } else {\n              dataIsGiven = true;\n              this._lastWrittenByte = data.byteLength;\n            }\n\n            var offset = options.offset ? options.offset >>> 0 : 0;\n            var byteLength = data.byteLength - offset;\n            var dvOffset = offset;\n\n            if (data.buffer) {\n              if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n              }\n\n              data = data.buffer;\n            }\n\n            if (dataIsGiven) {\n              this._lastWrittenByte = byteLength;\n            } else {\n              this._lastWrittenByte = 0;\n            }\n\n            this.buffer = data;\n            this.length = byteLength;\n            this.byteLength = byteLength;\n            this.byteOffset = dvOffset;\n            this.offset = 0;\n            this.littleEndian = true;\n            this._data = new DataView(this.buffer, dvOffset, byteLength);\n            this._mark = 0;\n            this._marks = [];\n          }\n          /**\r\n           * Checks if the memory allocated to the buffer is sufficient to store more bytes after the offset\r\n           * @param {number} [byteLength=1] The needed memory in bytes\r\n           * @return {boolean} Returns true if there is sufficient space and false otherwise\r\n           */\n\n          _createClass(IOBuffer, [{\n            key: 'available',\n            value: function available(byteLength) {\n              if (byteLength === undefined) byteLength = 1;\n              return this.offset + byteLength <= this.length;\n            }\n            /**\r\n             * Check if little-endian mode is used for reading and writing multi-byte values\r\n             * @return {boolean} Returns true if little-endian mode is used, false otherwise\r\n             */\n\n          }, {\n            key: 'isLittleEndian',\n            value: function isLittleEndian() {\n              return this.littleEndian;\n            }\n            /**\r\n             * Set little-endian mode for reading and writing multi-byte values\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'setLittleEndian',\n            value: function setLittleEndian() {\n              this.littleEndian = true;\n              return this;\n            }\n            /**\r\n             * Check if big-endian mode is used for reading and writing multi-byte values\r\n             * @return {boolean} Returns true if big-endian mode is used, false otherwise\r\n             */\n\n          }, {\n            key: 'isBigEndian',\n            value: function isBigEndian() {\n              return !this.littleEndian;\n            }\n            /**\r\n             * Switches to big-endian mode for reading and writing multi-byte values\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'setBigEndian',\n            value: function setBigEndian() {\n              this.littleEndian = false;\n              return this;\n            }\n            /**\r\n             * Move the pointer n bytes forward\r\n             * @param {number} n\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'skip',\n            value: function skip(n) {\n              if (n === undefined) n = 1;\n              this.offset += n;\n              return this;\n            }\n            /**\r\n             * Move the pointer to the given offset\r\n             * @param {number} offset\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'seek',\n            value: function seek(offset) {\n              this.offset = offset;\n              return this;\n            }\n            /**\r\n             * Store the current pointer offset.\r\n             * @see {@link IOBuffer#reset}\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'mark',\n            value: function mark() {\n              this._mark = this.offset;\n              return this;\n            }\n            /**\r\n             * Move the pointer back to the last pointer offset set by mark\r\n             * @see {@link IOBuffer#mark}\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'reset',\n            value: function reset() {\n              this.offset = this._mark;\n              return this;\n            }\n            /**\r\n             * Push the current pointer offset to the mark stack\r\n             * @see {@link IOBuffer#popMark}\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'pushMark',\n            value: function pushMark() {\n              this._marks.push(this.offset);\n\n              return this;\n            }\n            /**\r\n             * Pop the last pointer offset from the mark stack, and set the current pointer offset to the popped value\r\n             * @see {@link IOBuffer#pushMark}\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'popMark',\n            value: function popMark() {\n              var offset = this._marks.pop();\n\n              if (offset === undefined) throw new Error('Mark stack empty');\n              this.seek(offset);\n              return this;\n            }\n            /**\r\n             * Move the pointer offset back to 0\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'rewind',\n            value: function rewind() {\n              this.offset = 0;\n              return this;\n            }\n            /**\r\n             * Make sure the buffer has sufficient memory to write a given byteLength at the current pointer offset\r\n             * If the buffer's memory is insufficient, this method will create a new buffer (a copy) with a length\r\n             * that is twice (byteLength + current offset)\r\n             * @param {number} [byteLength = 1]\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'ensureAvailable',\n            value: function ensureAvailable(byteLength) {\n              if (byteLength === undefined) byteLength = 1;\n\n              if (!this.available(byteLength)) {\n                var lengthNeeded = this.offset + byteLength;\n                var newLength = lengthNeeded * 2;\n                var newArray = new Uint8Array(newLength);\n                newArray.set(new Uint8Array(this.buffer));\n                this.buffer = newArray.buffer;\n                this.length = this.byteLength = newLength;\n                this._data = new DataView(this.buffer);\n              }\n\n              return this;\n            }\n            /**\r\n             * Read a byte and return false if the byte's value is 0, or true otherwise\r\n             * Moves pointer forward\r\n             * @return {boolean}\r\n             */\n\n          }, {\n            key: 'readBoolean',\n            value: function readBoolean() {\n              return this.readUint8() !== 0;\n            }\n            /**\r\n             * Read a signed 8-bit integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readInt8',\n            value: function readInt8() {\n              return this._data.getInt8(this.offset++);\n            }\n            /**\r\n             * Read an unsigned 8-bit integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readUint8',\n            value: function readUint8() {\n              return this._data.getUint8(this.offset++);\n            }\n            /**\r\n             * Alias for {@link IOBuffer#readUint8}\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readByte',\n            value: function readByte() {\n              return this.readUint8();\n            }\n            /**\r\n             * Read n bytes and move pointer forward.\r\n             * @param {number} n\r\n             * @return {Uint8Array}\r\n             */\n\n          }, {\n            key: 'readBytes',\n            value: function readBytes(n) {\n              if (n === undefined) n = 1;\n              var bytes = new Uint8Array(n);\n\n              for (var i = 0; i < n; i++) {\n                bytes[i] = this.readByte();\n              }\n\n              return bytes;\n            }\n            /**\r\n             * Read a 16-bit signed integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readInt16',\n            value: function readInt16() {\n              var value = this._data.getInt16(this.offset, this.littleEndian);\n\n              this.offset += 2;\n              return value;\n            }\n            /**\r\n             * Read a 16-bit unsigned integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readUint16',\n            value: function readUint16() {\n              var value = this._data.getUint16(this.offset, this.littleEndian);\n\n              this.offset += 2;\n              return value;\n            }\n            /**\r\n             * Read a 32-bit signed integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readInt32',\n            value: function readInt32() {\n              var value = this._data.getInt32(this.offset, this.littleEndian);\n\n              this.offset += 4;\n              return value;\n            }\n            /**\r\n             * Read a 32-bit unsigned integer and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readUint32',\n            value: function readUint32() {\n              var value = this._data.getUint32(this.offset, this.littleEndian);\n\n              this.offset += 4;\n              return value;\n            }\n            /**\r\n             * Read a 32-bit floating number and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readFloat32',\n            value: function readFloat32() {\n              var value = this._data.getFloat32(this.offset, this.littleEndian);\n\n              this.offset += 4;\n              return value;\n            }\n            /**\r\n             * Read a 64-bit floating number and move pointer forward\r\n             * @return {number}\r\n             */\n\n          }, {\n            key: 'readFloat64',\n            value: function readFloat64() {\n              var value = this._data.getFloat64(this.offset, this.littleEndian);\n\n              this.offset += 8;\n              return value;\n            }\n            /**\r\n             * Read 1-byte ascii character and move pointer forward\r\n             * @return {string}\r\n             */\n\n          }, {\n            key: 'readChar',\n            value: function readChar() {\n              return String.fromCharCode(this.readInt8());\n            }\n            /**\r\n             * Read n 1-byte ascii characters and move pointer forward\r\n             * @param {number} n\r\n             * @return {string}\r\n             */\n\n          }, {\n            key: 'readChars',\n            value: function readChars(n) {\n              if (n === undefined) n = 1;\n              charArray.length = n;\n\n              for (var i = 0; i < n; i++) {\n                charArray[i] = this.readChar();\n              }\n\n              return charArray.join('');\n            }\n            /**\r\n             * Read the next n bytes, return a UTF-8 decoded string and move pointer forward\r\n             * @param {number} n\r\n             * @return {string}\r\n             */\n\n          }, {\n            key: 'readUtf8',\n            value: function readUtf8(n) {\n              if (n === undefined) n = 1;\n              var bString = this.readChars(n);\n              return utf8.decode(bString);\n            }\n            /**\r\n             * Write 0xff if the passed value is truthy, 0x00 otherwise\r\n             * @param {any} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeBoolean',\n            value: function writeBoolean(value) {\n              this.writeUint8(value ? 0xff : 0x00);\n              return this;\n            }\n            /**\r\n             * Write value as an 8-bit signed integer\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeInt8',\n            value: function writeInt8(value) {\n              this.ensureAvailable(1);\n\n              this._data.setInt8(this.offset++, value);\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write value as a 8-bit unsigned integer\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeUint8',\n            value: function writeUint8(value) {\n              this.ensureAvailable(1);\n\n              this._data.setUint8(this.offset++, value);\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * An alias for {@link IOBuffer#writeUint8}\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeByte',\n            value: function writeByte(value) {\n              return this.writeUint8(value);\n            }\n            /**\r\n             * Write bytes\r\n             * @param {Array|Uint8Array} bytes\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeBytes',\n            value: function writeBytes(bytes) {\n              this.ensureAvailable(bytes.length);\n\n              for (var i = 0; i < bytes.length; i++) {\n                this._data.setUint8(this.offset++, bytes[i]);\n              }\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write value as an 16-bit signed integer\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeInt16',\n            value: function writeInt16(value) {\n              this.ensureAvailable(2);\n\n              this._data.setInt16(this.offset, value, this.littleEndian);\n\n              this.offset += 2;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write value as a 16-bit unsigned integer\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeUint16',\n            value: function writeUint16(value) {\n              this.ensureAvailable(2);\n\n              this._data.setUint16(this.offset, value, this.littleEndian);\n\n              this.offset += 2;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write a 32-bit signed integer at the current pointer offset\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeInt32',\n            value: function writeInt32(value) {\n              this.ensureAvailable(4);\n\n              this._data.setInt32(this.offset, value, this.littleEndian);\n\n              this.offset += 4;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write a 32-bit unsigned integer at the current pointer offset\r\n             * @param {number} value - The value to set\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeUint32',\n            value: function writeUint32(value) {\n              this.ensureAvailable(4);\n\n              this._data.setUint32(this.offset, value, this.littleEndian);\n\n              this.offset += 4;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write a 32-bit floating number at the current pointer offset\r\n             * @param {number} value - The value to set\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeFloat32',\n            value: function writeFloat32(value) {\n              this.ensureAvailable(4);\n\n              this._data.setFloat32(this.offset, value, this.littleEndian);\n\n              this.offset += 4;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write a 64-bit floating number at the current pointer offset\r\n             * @param {number} value\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeFloat64',\n            value: function writeFloat64(value) {\n              this.ensureAvailable(8);\n\n              this._data.setFloat64(this.offset, value, this.littleEndian);\n\n              this.offset += 8;\n\n              this._updateLastWrittenByte();\n\n              return this;\n            }\n            /**\r\n             * Write the charCode of the passed string's first character to the current pointer offset\r\n             * @param {string} str - The character to set\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeChar',\n            value: function writeChar(str) {\n              return this.writeUint8(str.charCodeAt(0));\n            }\n            /**\r\n             * Write the charCodes of the passed string's characters to the current pointer offset\r\n             * @param {string} str\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeChars',\n            value: function writeChars(str) {\n              for (var i = 0; i < str.length; i++) {\n                this.writeUint8(str.charCodeAt(i));\n              }\n\n              return this;\n            }\n            /**\r\n             * UTF-8 encode and write the passed string to the current pointer offset\r\n             * @param {string} str\r\n             * @return {IOBuffer}\r\n             */\n\n          }, {\n            key: 'writeUtf8',\n            value: function writeUtf8(str) {\n              var bString = utf8.encode(str);\n              return this.writeChars(bString);\n            }\n            /**\r\n             * Export a Uint8Array view of the internal buffer.\r\n             * The view starts at the byte offset and its length\r\n             * is calculated to stop at the last written byte or the original length.\r\n             * @return {Uint8Array}\r\n             */\n\n          }, {\n            key: 'toArray',\n            value: function toArray() {\n              return new Uint8Array(this.buffer, this.byteOffset, this._lastWrittenByte);\n            }\n            /**\r\n             * Same as {@link IOBuffer#toArray} but returns a Buffer if possible. Otherwise returns a Uint8Array.\r\n             * @return {Buffer|Uint8Array}\r\n             */\n\n          }, {\n            key: 'getBuffer',\n            value: function getBuffer() {\n              if (typeof Buffer !== 'undefined') {\n                return Buffer.from(this.toArray());\n              } else {\n                return this.toArray();\n              }\n            }\n            /**\r\n             * Update the last written byte offset\r\n             * @private\r\n             */\n\n          }, {\n            key: '_updateLastWrittenByte',\n            value: function _updateLastWrittenByte() {\n              if (this.offset > this._lastWrittenByte) {\n                this._lastWrittenByte = this.offset;\n              }\n            }\n          }]);\n\n          return IOBuffer;\n        }();\n\n        module.exports = IOBuffer;\n        /* WEBPACK VAR INJECTION */\n      }).call(this, __webpack_require__(5).Buffer);\n\n      /***/\n    },\n    /* 5 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n      (function (global) {\n        /*!\r\n        * The buffer module from node.js, for the browser.\r\n        *\r\n        * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n        * @license  MIT\r\n        */\n\n        /* eslint-disable no-proto */\n\n        var base64 = __webpack_require__(6);\n\n        var ieee754 = __webpack_require__(7);\n\n        var isArray = __webpack_require__(8);\n\n        exports.Buffer = Buffer;\n        exports.SlowBuffer = SlowBuffer;\n        exports.INSPECT_MAX_BYTES = 50;\n        /**\r\n         * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n         *   === true    Use Uint8Array implementation (fastest)\r\n         *   === false   Use Object implementation (most compatible, even IE6)\r\n         *\r\n         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n         * Opera 11.6+, iOS 4.2+.\r\n         *\r\n         * Due to various browser bugs, sometimes the Object implementation will be used even\r\n         * when the browser supports typed arrays.\r\n         *\r\n         * Note:\r\n         *\r\n         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\r\n         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\r\n         *\r\n         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\r\n         *\r\n         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\r\n         *     incorrect length in some situations.\r\n        \r\n         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\r\n         * get the Object implementation, which is slower but behaves correctly.\r\n         */\n\n        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n        /*\r\n         * Export kMaxLength after typed array support is determined.\r\n         */\n\n        exports.kMaxLength = kMaxLength();\n\n        function typedArraySupport() {\n          try {\n            var arr = new Uint8Array(1);\n            arr.__proto__ = {\n              __proto__: Uint8Array.prototype,\n              foo: function foo() {\n                return 42;\n              }\n            };\n            return arr.foo() === 42 && // typed array instances can be augmented\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function kMaxLength() {\n          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n        }\n\n        function createBuffer(that, length) {\n          if (kMaxLength() < length) {\n            throw new RangeError('Invalid typed array length');\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = new Uint8Array(length);\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            if (that === null) {\n              that = new Buffer(length);\n            }\n\n            that.length = length;\n          }\n\n          return that;\n        }\n        /**\r\n         * The Buffer constructor returns instances of `Uint8Array` that have their\r\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n         * returns a single octet.\r\n         *\r\n         * The `Uint8Array` prototype remains unmodified.\r\n         */\n\n        function Buffer(arg, encodingOrOffset, length) {\n          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n            return new Buffer(arg, encodingOrOffset, length);\n          } // Common case.\n\n\n          if (typeof arg === 'number') {\n            if (typeof encodingOrOffset === 'string') {\n              throw new Error('If encoding is specified then the first argument must be a string');\n            }\n\n            return allocUnsafe(this, arg);\n          }\n\n          return from(this, arg, encodingOrOffset, length);\n        }\n\n        Buffer.poolSize = 8192; // not used by this implementation\n        // TODO: Legacy, not needed anymore. Remove in next major version.\n\n        Buffer._augment = function (arr) {\n          arr.__proto__ = Buffer.prototype;\n          return arr;\n        };\n\n        function from(that, value, encodingOrOffset, length) {\n          if (typeof value === 'number') {\n            throw new TypeError('\"value\" argument must not be a number');\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n            return fromArrayBuffer(that, value, encodingOrOffset, length);\n          }\n\n          if (typeof value === 'string') {\n            return fromString(that, value, encodingOrOffset);\n          }\n\n          return fromObject(that, value);\n        }\n        /**\r\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n         * if value is a number.\r\n         * Buffer.from(str[, encoding])\r\n         * Buffer.from(array)\r\n         * Buffer.from(buffer)\r\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n         **/\n\n        Buffer.from = function (value, encodingOrOffset, length) {\n          return from(null, value, encodingOrOffset, length);\n        };\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true\n            });\n          }\n        }\n\n        function assertSize(size) {\n          if (typeof size !== 'number') {\n            throw new TypeError('\"size\" argument must be a number');\n          } else if (size < 0) {\n            throw new RangeError('\"size\" argument must not be negative');\n          }\n        }\n\n        function alloc(that, size, fill, encoding) {\n          assertSize(size);\n\n          if (size <= 0) {\n            return createBuffer(that, size);\n          }\n\n          if (fill !== undefined) {\n            // Only pay attention to encoding if it's a string. This\n            // prevents accidentally sending in a number that would\n            // be interpretted as a start offset.\n            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n          }\n\n          return createBuffer(that, size);\n        }\n        /**\r\n         * Creates a new filled Buffer instance.\r\n         * alloc(size[, fill[, encoding]])\r\n         **/\n\n        Buffer.alloc = function (size, fill, encoding) {\n          return alloc(null, size, fill, encoding);\n        };\n\n        function allocUnsafe(that, size) {\n          assertSize(size);\n          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT) {\n            for (var i = 0; i < size; ++i) {\n              that[i] = 0;\n            }\n          }\n\n          return that;\n        }\n        /**\r\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n         * */\n\n        Buffer.allocUnsafe = function (size) {\n          return allocUnsafe(null, size);\n        };\n        /**\r\n         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n         */\n\n        Buffer.allocUnsafeSlow = function (size) {\n          return allocUnsafe(null, size);\n        };\n\n        function fromString(that, string, encoding) {\n          if (typeof encoding !== 'string' || encoding === '') {\n            encoding = 'utf8';\n          }\n\n          if (!Buffer.isEncoding(encoding)) {\n            throw new TypeError('\"encoding\" must be a valid string encoding');\n          }\n\n          var length = byteLength(string, encoding) | 0;\n          that = createBuffer(that, length);\n          var actual = that.write(string, encoding);\n\n          if (actual !== length) {\n            // Writing a hex string, for example, that contains invalid characters will\n            // cause everything after the first invalid character to be ignored. (e.g.\n            // 'abxxcd' will be treated as 'ab')\n            that = that.slice(0, actual);\n          }\n\n          return that;\n        }\n\n        function fromArrayLike(that, array) {\n          var length = array.length < 0 ? 0 : checked(array.length) | 0;\n          that = createBuffer(that, length);\n\n          for (var i = 0; i < length; i += 1) {\n            that[i] = array[i] & 255;\n          }\n\n          return that;\n        }\n\n        function fromArrayBuffer(that, array, byteOffset, length) {\n          array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n          if (byteOffset < 0 || array.byteLength < byteOffset) {\n            throw new RangeError('\\'offset\\' is out of bounds');\n          }\n\n          if (array.byteLength < byteOffset + (length || 0)) {\n            throw new RangeError('\\'length\\' is out of bounds');\n          }\n\n          if (byteOffset === undefined && length === undefined) {\n            array = new Uint8Array(array);\n          } else if (length === undefined) {\n            array = new Uint8Array(array, byteOffset);\n          } else {\n            array = new Uint8Array(array, byteOffset, length);\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = array;\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            that = fromArrayLike(that, array);\n          }\n\n          return that;\n        }\n\n        function fromObject(that, obj) {\n          if (Buffer.isBuffer(obj)) {\n            var len = checked(obj.length) | 0;\n            that = createBuffer(that, len);\n\n            if (that.length === 0) {\n              return that;\n            }\n\n            obj.copy(that, 0, 0, len);\n            return that;\n          }\n\n          if (obj) {\n            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n              if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n              }\n\n              return fromArrayLike(that, obj);\n            }\n\n            if (obj.type === 'Buffer' && isArray(obj.data)) {\n              return fromArrayLike(that, obj.data);\n            }\n          }\n\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n        }\n\n        function checked(length) {\n          // Note: cannot use `length < kMaxLength()` here because that fails when\n          // length is NaN (which is otherwise coerced to zero.)\n          if (length >= kMaxLength()) {\n            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n          }\n\n          return length | 0;\n        }\n\n        function SlowBuffer(length) {\n          if (+length != length) {\n            // eslint-disable-line eqeqeq\n            length = 0;\n          }\n\n          return Buffer.alloc(+length);\n        }\n\n        Buffer.isBuffer = function isBuffer(b) {\n          return !!(b != null && b._isBuffer);\n        };\n\n        Buffer.compare = function compare(a, b) {\n          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n            throw new TypeError('Arguments must be Buffers');\n          }\n\n          if (a === b) return 0;\n          var x = a.length;\n          var y = b.length;\n\n          for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n            if (a[i] !== b[i]) {\n              x = a[i];\n              y = b[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        };\n\n        Buffer.isEncoding = function isEncoding(encoding) {\n          switch (String(encoding).toLowerCase()) {\n            case 'hex':\n            case 'utf8':\n            case 'utf-8':\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n            case 'base64':\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return true;\n\n            default:\n              return false;\n          }\n        };\n\n        Buffer.concat = function concat(list, length) {\n          if (!isArray(list)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          if (list.length === 0) {\n            return Buffer.alloc(0);\n          }\n\n          var i;\n\n          if (length === undefined) {\n            length = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              length += list[i].length;\n            }\n          }\n\n          var buffer = Buffer.allocUnsafe(length);\n          var pos = 0;\n\n          for (i = 0; i < list.length; ++i) {\n            var buf = list[i];\n\n            if (!Buffer.isBuffer(buf)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            buf.copy(buffer, pos);\n            pos += buf.length;\n          }\n\n          return buffer;\n        };\n\n        function byteLength(string, encoding) {\n          if (Buffer.isBuffer(string)) {\n            return string.length;\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n            return string.byteLength;\n          }\n\n          if (typeof string !== 'string') {\n            string = '' + string;\n          }\n\n          var len = string.length;\n          if (len === 0) return 0; // Use a for loop to avoid recursion\n\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n                return len;\n\n              case 'utf8':\n              case 'utf-8':\n              case undefined:\n                return utf8ToBytes(string).length;\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return len * 2;\n\n              case 'hex':\n                return len >>> 1;\n\n              case 'base64':\n                return base64ToBytes(string).length;\n\n              default:\n                if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        }\n\n        Buffer.byteLength = byteLength;\n\n        function slowToString(encoding, start, end) {\n          var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n          // property of a typed array.\n          // This behaves neither like String nor Uint8Array in that we set start/end\n          // to their upper/lower bounds if the value passed is out of range.\n          // undefined is handled specially as per ECMA-262 6th Edition,\n          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n          if (start === undefined || start < 0) {\n            start = 0;\n          } // Return early if start > this.length. Done here to prevent potential uint32\n          // coercion fail below.\n\n\n          if (start > this.length) {\n            return '';\n          }\n\n          if (end === undefined || end > this.length) {\n            end = this.length;\n          }\n\n          if (end <= 0) {\n            return '';\n          } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n          end >>>= 0;\n          start >>>= 0;\n\n          if (end <= start) {\n            return '';\n          }\n\n          if (!encoding) encoding = 'utf8';\n\n          while (true) {\n            switch (encoding) {\n              case 'hex':\n                return hexSlice(this, start, end);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Slice(this, start, end);\n\n              case 'ascii':\n                return asciiSlice(this, start, end);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Slice(this, start, end);\n\n              case 'base64':\n                return base64Slice(this, start, end);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return utf16leSlice(this, start, end);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n            }\n          }\n        } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n        // Buffer instances.\n\n\n        Buffer.prototype._isBuffer = true;\n\n        function swap(b, n, m) {\n          var i = b[n];\n          b[n] = b[m];\n          b[m] = i;\n        }\n\n        Buffer.prototype.swap16 = function swap16() {\n          var len = this.length;\n\n          if (len % 2 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 16-bits');\n          }\n\n          for (var i = 0; i < len; i += 2) {\n            swap(this, i, i + 1);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap32 = function swap32() {\n          var len = this.length;\n\n          if (len % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n          }\n\n          for (var i = 0; i < len; i += 4) {\n            swap(this, i, i + 3);\n            swap(this, i + 1, i + 2);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap64 = function swap64() {\n          var len = this.length;\n\n          if (len % 8 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 64-bits');\n          }\n\n          for (var i = 0; i < len; i += 8) {\n            swap(this, i, i + 7);\n            swap(this, i + 1, i + 6);\n            swap(this, i + 2, i + 5);\n            swap(this, i + 3, i + 4);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.toString = function toString() {\n          var length = this.length | 0;\n          if (length === 0) return '';\n          if (arguments.length === 0) return utf8Slice(this, 0, length);\n          return slowToString.apply(this, arguments);\n        };\n\n        Buffer.prototype.equals = function equals(b) {\n          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n          if (this === b) return true;\n          return Buffer.compare(this, b) === 0;\n        };\n\n        Buffer.prototype.inspect = function inspect() {\n          var str = '';\n          var max = exports.INSPECT_MAX_BYTES;\n\n          if (this.length > 0) {\n            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n            if (this.length > max) str += ' ... ';\n          }\n\n          return '<Buffer ' + str + '>';\n        };\n\n        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n          if (!Buffer.isBuffer(target)) {\n            throw new TypeError('Argument must be a Buffer');\n          }\n\n          if (start === undefined) {\n            start = 0;\n          }\n\n          if (end === undefined) {\n            end = target ? target.length : 0;\n          }\n\n          if (thisStart === undefined) {\n            thisStart = 0;\n          }\n\n          if (thisEnd === undefined) {\n            thisEnd = this.length;\n          }\n\n          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n            throw new RangeError('out of range index');\n          }\n\n          if (thisStart >= thisEnd && start >= end) {\n            return 0;\n          }\n\n          if (thisStart >= thisEnd) {\n            return -1;\n          }\n\n          if (start >= end) {\n            return 1;\n          }\n\n          start >>>= 0;\n          end >>>= 0;\n          thisStart >>>= 0;\n          thisEnd >>>= 0;\n          if (this === target) return 0;\n          var x = thisEnd - thisStart;\n          var y = end - start;\n          var len = Math.min(x, y);\n          var thisCopy = this.slice(thisStart, thisEnd);\n          var targetCopy = target.slice(start, end);\n\n          for (var i = 0; i < len; ++i) {\n            if (thisCopy[i] !== targetCopy[i]) {\n              x = thisCopy[i];\n              y = targetCopy[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n        //\n        // Arguments:\n        // - buffer - a Buffer to search\n        // - val - a string, Buffer, or number\n        // - byteOffset - an index into `buffer`; will be clamped to an int32\n        // - encoding - an optional encoding, relevant is val is a string\n        // - dir - true for indexOf, false for lastIndexOf\n\n\n        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n          // Empty buffer means no match\n          if (buffer.length === 0) return -1; // Normalize byteOffset\n\n          if (typeof byteOffset === 'string') {\n            encoding = byteOffset;\n            byteOffset = 0;\n          } else if (byteOffset > 0x7fffffff) {\n            byteOffset = 0x7fffffff;\n          } else if (byteOffset < -0x80000000) {\n            byteOffset = -0x80000000;\n          }\n\n          byteOffset = +byteOffset; // Coerce to Number.\n\n          if (isNaN(byteOffset)) {\n            // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n            byteOffset = dir ? 0 : buffer.length - 1;\n          } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n          if (byteOffset >= buffer.length) {\n            if (dir) return -1;else byteOffset = buffer.length - 1;\n          } else if (byteOffset < 0) {\n            if (dir) byteOffset = 0;else return -1;\n          } // Normalize val\n\n\n          if (typeof val === 'string') {\n            val = Buffer.from(val, encoding);\n          } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n          if (Buffer.isBuffer(val)) {\n            // Special case: looking for empty string/buffer always fails\n            if (val.length === 0) {\n              return -1;\n            }\n\n            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n          } else if (typeof val === 'number') {\n            val = val & 0xFF; // Search for a byte value [0-255]\n\n            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n              if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n              } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n              }\n            }\n\n            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n          }\n\n          throw new TypeError('val must be string, number or Buffer');\n        }\n\n        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n          var indexSize = 1;\n          var arrLength = arr.length;\n          var valLength = val.length;\n\n          if (encoding !== undefined) {\n            encoding = String(encoding).toLowerCase();\n\n            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n              if (arr.length < 2 || val.length < 2) {\n                return -1;\n              }\n\n              indexSize = 2;\n              arrLength /= 2;\n              valLength /= 2;\n              byteOffset /= 2;\n            }\n          }\n\n          function read(buf, i) {\n            if (indexSize === 1) {\n              return buf[i];\n            } else {\n              return buf.readUInt16BE(i * indexSize);\n            }\n          }\n\n          var i;\n\n          if (dir) {\n            var foundIndex = -1;\n\n            for (i = byteOffset; i < arrLength; i++) {\n              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n              } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n              }\n            }\n          } else {\n            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n            for (i = byteOffset; i >= 0; i--) {\n              var found = true;\n\n              for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                  found = false;\n                  break;\n                }\n              }\n\n              if (found) return i;\n            }\n          }\n\n          return -1;\n        }\n\n        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n          return this.indexOf(val, byteOffset, encoding) !== -1;\n        };\n\n        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n        };\n\n        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n        };\n\n        function hexWrite(buf, string, offset, length) {\n          offset = Number(offset) || 0;\n          var remaining = buf.length - offset;\n\n          if (!length) {\n            length = remaining;\n          } else {\n            length = Number(length);\n\n            if (length > remaining) {\n              length = remaining;\n            }\n          } // must be an even number of digits\n\n\n          var strLen = string.length;\n          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n          if (length > strLen / 2) {\n            length = strLen / 2;\n          }\n\n          for (var i = 0; i < length; ++i) {\n            var parsed = parseInt(string.substr(i * 2, 2), 16);\n            if (isNaN(parsed)) return i;\n            buf[offset + i] = parsed;\n          }\n\n          return i;\n        }\n\n        function utf8Write(buf, string, offset, length) {\n          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        function asciiWrite(buf, string, offset, length) {\n          return blitBuffer(asciiToBytes(string), buf, offset, length);\n        }\n\n        function latin1Write(buf, string, offset, length) {\n          return asciiWrite(buf, string, offset, length);\n        }\n\n        function base64Write(buf, string, offset, length) {\n          return blitBuffer(base64ToBytes(string), buf, offset, length);\n        }\n\n        function ucs2Write(buf, string, offset, length) {\n          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        Buffer.prototype.write = function write(string, offset, length, encoding) {\n          // Buffer#write(string)\n          if (offset === undefined) {\n            encoding = 'utf8';\n            length = this.length;\n            offset = 0; // Buffer#write(string, encoding)\n          } else if (length === undefined && typeof offset === 'string') {\n            encoding = offset;\n            length = this.length;\n            offset = 0; // Buffer#write(string, offset[, length][, encoding])\n          } else if (isFinite(offset)) {\n            offset = offset | 0;\n\n            if (isFinite(length)) {\n              length = length | 0;\n              if (encoding === undefined) encoding = 'utf8';\n            } else {\n              encoding = length;\n              length = undefined;\n            } // legacy write(string, encoding, offset, length) - remove in v0.13\n          } else {\n            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n          }\n\n          var remaining = this.length - offset;\n          if (length === undefined || length > remaining) length = remaining;\n\n          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n            throw new RangeError('Attempt to write outside buffer bounds');\n          }\n\n          if (!encoding) encoding = 'utf8';\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'hex':\n                return hexWrite(this, string, offset, length);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Write(this, string, offset, length);\n\n              case 'ascii':\n                return asciiWrite(this, string, offset, length);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Write(this, string, offset, length);\n\n              case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        };\n\n        Buffer.prototype.toJSON = function toJSON() {\n          return {\n            type: 'Buffer',\n            data: Array.prototype.slice.call(this._arr || this, 0)\n          };\n        };\n\n        function base64Slice(buf, start, end) {\n          if (start === 0 && end === buf.length) {\n            return base64.fromByteArray(buf);\n          } else {\n            return base64.fromByteArray(buf.slice(start, end));\n          }\n        }\n\n        function utf8Slice(buf, start, end) {\n          end = Math.min(buf.length, end);\n          var res = [];\n          var i = start;\n\n          while (i < end) {\n            var firstByte = buf[i];\n            var codePoint = null;\n            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n            if (i + bytesPerSequence <= end) {\n              var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n              switch (bytesPerSequence) {\n                case 1:\n                  if (firstByte < 0x80) {\n                    codePoint = firstByte;\n                  }\n\n                  break;\n\n                case 2:\n                  secondByte = buf[i + 1];\n\n                  if ((secondByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                    if (tempCodePoint > 0x7F) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 3:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 4:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  fourthByte = buf[i + 3];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n              }\n            }\n\n            if (codePoint === null) {\n              // we did not generate a valid codePoint so insert a\n              // replacement char (U+FFFD) and advance only 1 byte\n              codePoint = 0xFFFD;\n              bytesPerSequence = 1;\n            } else if (codePoint > 0xFFFF) {\n              // encode to utf16 (surrogate pair dance)\n              codePoint -= 0x10000;\n              res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n              codePoint = 0xDC00 | codePoint & 0x3FF;\n            }\n\n            res.push(codePoint);\n            i += bytesPerSequence;\n          }\n\n          return decodeCodePointsArray(res);\n        } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n        // the lowest limit is Chrome, with 0x10000 args.\n        // We go 1 magnitude less, for safety\n\n\n        var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n        function decodeCodePointsArray(codePoints) {\n          var len = codePoints.length;\n\n          if (len <= MAX_ARGUMENTS_LENGTH) {\n            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n          } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n          var res = '';\n          var i = 0;\n\n          while (i < len) {\n            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n          }\n\n          return res;\n        }\n\n        function asciiSlice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i] & 0x7F);\n          }\n\n          return ret;\n        }\n\n        function latin1Slice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i]);\n          }\n\n          return ret;\n        }\n\n        function hexSlice(buf, start, end) {\n          var len = buf.length;\n          if (!start || start < 0) start = 0;\n          if (!end || end < 0 || end > len) end = len;\n          var out = '';\n\n          for (var i = start; i < end; ++i) {\n            out += toHex(buf[i]);\n          }\n\n          return out;\n        }\n\n        function utf16leSlice(buf, start, end) {\n          var bytes = buf.slice(start, end);\n          var res = '';\n\n          for (var i = 0; i < bytes.length; i += 2) {\n            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n          }\n\n          return res;\n        }\n\n        Buffer.prototype.slice = function slice(start, end) {\n          var len = this.length;\n          start = ~~start;\n          end = end === undefined ? len : ~~end;\n\n          if (start < 0) {\n            start += len;\n            if (start < 0) start = 0;\n          } else if (start > len) {\n            start = len;\n          }\n\n          if (end < 0) {\n            end += len;\n            if (end < 0) end = 0;\n          } else if (end > len) {\n            end = len;\n          }\n\n          if (end < start) end = start;\n          var newBuf;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            newBuf = this.subarray(start, end);\n            newBuf.__proto__ = Buffer.prototype;\n          } else {\n            var sliceLen = end - start;\n            newBuf = new Buffer(sliceLen, undefined);\n\n            for (var i = 0; i < sliceLen; ++i) {\n              newBuf[i] = this[i + start];\n            }\n          }\n\n          return newBuf;\n        };\n        /*\r\n         * Need to make sure that buffer isn't trying to write out of bounds.\r\n         */\n\n        function checkOffset(offset, ext, length) {\n          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n        }\n\n        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            checkOffset(offset, byteLength, this.length);\n          }\n\n          var val = this[offset + --byteLength];\n          var mul = 1;\n\n          while (byteLength > 0 && (mul *= 0x100)) {\n            val += this[offset + --byteLength] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          return this[offset];\n        };\n\n        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] | this[offset + 1] << 8;\n        };\n\n        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] << 8 | this[offset + 1];\n        };\n\n        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n        };\n\n        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n        };\n\n        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var i = byteLength;\n          var mul = 1;\n          var val = this[offset + --i];\n\n          while (i > 0 && (mul *= 0x100)) {\n            val += this[offset + --i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          if (!(this[offset] & 0x80)) return this[offset];\n          return (0xff - this[offset] + 1) * -1;\n        };\n\n        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset] | this[offset + 1] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset + 1] | this[offset] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n        };\n\n        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n        };\n\n        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, true, 23, 4);\n        };\n\n        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, false, 23, 4);\n        };\n\n        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, true, 52, 8);\n        };\n\n        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, false, 52, 8);\n        };\n\n        function checkInt(buf, value, offset, ext, max, min) {\n          if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n          if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        }\n\n        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var mul = 1;\n          var i = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        function objectWriteUInt16(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n          }\n        }\n\n        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        function objectWriteUInt32(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n          }\n        }\n\n        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = 0;\n          var mul = 1;\n          var sub = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          var sub = 0;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          if (value < 0) value = 0xff + value + 1;\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        function checkIEEE754(buf, value, offset, ext, max, min) {\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          if (offset < 0) throw new RangeError('Index out of range');\n        }\n\n        function writeFloat(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 23, 4);\n          return offset + 4;\n        }\n\n        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, false, noAssert);\n        };\n\n        function writeDouble(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 52, 8);\n          return offset + 8;\n        }\n\n        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, false, noAssert);\n        }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n        Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n          if (!start) start = 0;\n          if (!end && end !== 0) end = this.length;\n          if (targetStart >= target.length) targetStart = target.length;\n          if (!targetStart) targetStart = 0;\n          if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n          if (end === start) return 0;\n          if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n          if (targetStart < 0) {\n            throw new RangeError('targetStart out of bounds');\n          }\n\n          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n          if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n          if (end > this.length) end = this.length;\n\n          if (target.length - targetStart < end - start) {\n            end = target.length - targetStart + start;\n          }\n\n          var len = end - start;\n          var i;\n\n          if (this === target && start < targetStart && targetStart < end) {\n            // descending copy from end\n            for (i = len - 1; i >= 0; --i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n            // ascending copy from start\n            for (i = 0; i < len; ++i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else {\n            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n          }\n\n          return len;\n        }; // Usage:\n        //    buffer.fill(number[, offset[, end]])\n        //    buffer.fill(buffer[, offset[, end]])\n        //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n        Buffer.prototype.fill = function fill(val, start, end, encoding) {\n          // Handle string cases:\n          if (typeof val === 'string') {\n            if (typeof start === 'string') {\n              encoding = start;\n              start = 0;\n              end = this.length;\n            } else if (typeof end === 'string') {\n              encoding = end;\n              end = this.length;\n            }\n\n            if (val.length === 1) {\n              var code = val.charCodeAt(0);\n\n              if (code < 256) {\n                val = code;\n              }\n            }\n\n            if (encoding !== undefined && typeof encoding !== 'string') {\n              throw new TypeError('encoding must be a string');\n            }\n\n            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n          } else if (typeof val === 'number') {\n            val = val & 255;\n          } // Invalid ranges are not set to a default, so can range check early.\n\n\n          if (start < 0 || this.length < start || this.length < end) {\n            throw new RangeError('Out of range index');\n          }\n\n          if (end <= start) {\n            return this;\n          }\n\n          start = start >>> 0;\n          end = end === undefined ? this.length : end >>> 0;\n          if (!val) val = 0;\n          var i;\n\n          if (typeof val === 'number') {\n            for (i = start; i < end; ++i) {\n              this[i] = val;\n            }\n          } else {\n            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n            var len = bytes.length;\n\n            for (i = 0; i < end - start; ++i) {\n              this[i + start] = bytes[i % len];\n            }\n          }\n\n          return this;\n        }; // HELPER FUNCTIONS\n        // ================\n\n\n        var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n        function base64clean(str) {\n          // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n          str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n          if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n          while (str.length % 4 !== 0) {\n            str = str + '=';\n          }\n\n          return str;\n        }\n\n        function stringtrim(str) {\n          if (str.trim) return str.trim();\n          return str.replace(/^\\s+|\\s+$/g, '');\n        }\n\n        function toHex(n) {\n          if (n < 16) return '0' + n.toString(16);\n          return n.toString(16);\n        }\n\n        function utf8ToBytes(string, units) {\n          units = units || Infinity;\n          var codePoint;\n          var length = string.length;\n          var leadSurrogate = null;\n          var bytes = [];\n\n          for (var i = 0; i < length; ++i) {\n            codePoint = string.charCodeAt(i); // is surrogate component\n\n            if (codePoint > 0xD7FF && codePoint < 0xE000) {\n              // last char was a lead\n              if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                  // unexpected trail\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } else if (i + 1 === length) {\n                  // unpaired lead\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } // valid lead\n\n\n                leadSurrogate = codePoint;\n                continue;\n              } // 2 leads in a row\n\n\n              if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n              } // valid surrogate pair\n\n\n              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n            } else if (leadSurrogate) {\n              // valid bmp char, but last char was a lead\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            }\n\n            leadSurrogate = null; // encode utf8\n\n            if (codePoint < 0x80) {\n              if ((units -= 1) < 0) break;\n              bytes.push(codePoint);\n            } else if (codePoint < 0x800) {\n              if ((units -= 2) < 0) break;\n              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x10000) {\n              if ((units -= 3) < 0) break;\n              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x110000) {\n              if ((units -= 4) < 0) break;\n              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else {\n              throw new Error('Invalid code point');\n            }\n          }\n\n          return bytes;\n        }\n\n        function asciiToBytes(str) {\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            // Node's code seems to be doing this and not & 0x7F..\n            byteArray.push(str.charCodeAt(i) & 0xFF);\n          }\n\n          return byteArray;\n        }\n\n        function utf16leToBytes(str, units) {\n          var c, hi, lo;\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            if ((units -= 2) < 0) break;\n            c = str.charCodeAt(i);\n            hi = c >> 8;\n            lo = c % 256;\n            byteArray.push(lo);\n            byteArray.push(hi);\n          }\n\n          return byteArray;\n        }\n\n        function base64ToBytes(str) {\n          return base64.toByteArray(base64clean(str));\n        }\n\n        function blitBuffer(src, dst, offset, length) {\n          for (var i = 0; i < length; ++i) {\n            if (i + offset >= dst.length || i >= src.length) break;\n            dst[i + offset] = src[i];\n          }\n\n          return i;\n        }\n\n        function isnan(val) {\n          return val !== val; // eslint-disable-line no-self-compare\n        }\n        /* WEBPACK VAR INJECTION */\n      }).call(this, __webpack_require__(1));\n\n      /***/\n    },\n    /* 6 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      } // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        } // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      } // base64 is 4/3 + up to two characters of the original data\n\n\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n        for (var i = 0; i < len; i += 4) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n        // go through the array every three bytes, we'll deal with trailing stuff later\n\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n        }\n\n        return parts.join('');\n      }\n\n      /***/\n    },\n    /* 7 */\n    /***/function (module, exports) {\n\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n      /***/\n    },\n    /* 8 */\n    /***/function (module, exports) {\n\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n\n      /***/\n    },\n    /* 9 */\n    /***/function (module, exports, __webpack_require__) {\n\n      /* WEBPACK VAR INJECTION */(function (module, global) {\n        var __WEBPACK_AMD_DEFINE_RESULT__; /*! https://mths.be/utf8js v2.1.2 by @mathias */\n        ;\n\n        (function (root) {\n          // Detect free variables `exports`\n          var freeExports =  true && exports; // Detect free variable `module`\n\n          var freeModule =  true && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code,\n          // and use it as `root`\n\n          var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;\n\n          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n            root = freeGlobal;\n          }\n          /*--------------------------------------------------------------------------*/\n\n          var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode\n\n          function ucs2decode(string) {\n            var output = [];\n            var counter = 0;\n            var length = string.length;\n            var value;\n            var extra;\n\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n\n                if ((extra & 0xFC00) == 0xDC00) {\n                  // low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n\n            return output;\n          } // Taken from https://mths.be/punycode\n\n\n          function ucs2encode(array) {\n            var length = array.length;\n            var index = -1;\n            var value;\n            var output = '';\n\n            while (++index < length) {\n              value = array[index];\n\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n\n              output += stringFromCharCode(value);\n            }\n\n            return output;\n          }\n\n          function checkScalarValue(codePoint) {\n            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n              throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');\n            }\n          }\n          /*--------------------------------------------------------------------------*/\n\n          function createByte(codePoint, shift) {\n            return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);\n          }\n\n          function encodeCodePoint(codePoint) {\n            if ((codePoint & 0xFFFFFF80) == 0) {\n              // 1-byte sequence\n              return stringFromCharCode(codePoint);\n            }\n\n            var symbol = '';\n\n            if ((codePoint & 0xFFFFF800) == 0) {\n              // 2-byte sequence\n              symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);\n            } else if ((codePoint & 0xFFFF0000) == 0) {\n              // 3-byte sequence\n              checkScalarValue(codePoint);\n              symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);\n              symbol += createByte(codePoint, 6);\n            } else if ((codePoint & 0xFFE00000) == 0) {\n              // 4-byte sequence\n              symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);\n              symbol += createByte(codePoint, 12);\n              symbol += createByte(codePoint, 6);\n            }\n\n            symbol += stringFromCharCode(codePoint & 0x3F | 0x80);\n            return symbol;\n          }\n\n          function utf8encode(string) {\n            var codePoints = ucs2decode(string);\n            var length = codePoints.length;\n            var index = -1;\n            var codePoint;\n            var byteString = '';\n\n            while (++index < length) {\n              codePoint = codePoints[index];\n              byteString += encodeCodePoint(codePoint);\n            }\n\n            return byteString;\n          }\n          /*--------------------------------------------------------------------------*/\n\n          function readContinuationByte() {\n            if (byteIndex >= byteCount) {\n              throw Error('Invalid byte index');\n            }\n\n            var continuationByte = byteArray[byteIndex] & 0xFF;\n            byteIndex++;\n\n            if ((continuationByte & 0xC0) == 0x80) {\n              return continuationByte & 0x3F;\n            } // If we end up here, its not a continuation byte\n\n\n            throw Error('Invalid continuation byte');\n          }\n\n          function decodeSymbol() {\n            var byte1;\n            var byte2;\n            var byte3;\n            var byte4;\n            var codePoint;\n\n            if (byteIndex > byteCount) {\n              throw Error('Invalid byte index');\n            }\n\n            if (byteIndex == byteCount) {\n              return false;\n            } // Read first byte\n\n\n            byte1 = byteArray[byteIndex] & 0xFF;\n            byteIndex++; // 1-byte sequence (no continuation bytes)\n\n            if ((byte1 & 0x80) == 0) {\n              return byte1;\n            } // 2-byte sequence\n\n\n            if ((byte1 & 0xE0) == 0xC0) {\n              byte2 = readContinuationByte();\n              codePoint = (byte1 & 0x1F) << 6 | byte2;\n\n              if (codePoint >= 0x80) {\n                return codePoint;\n              } else {\n                throw Error('Invalid continuation byte');\n              }\n            } // 3-byte sequence (may include unpaired surrogates)\n\n\n            if ((byte1 & 0xF0) == 0xE0) {\n              byte2 = readContinuationByte();\n              byte3 = readContinuationByte();\n              codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;\n\n              if (codePoint >= 0x0800) {\n                checkScalarValue(codePoint);\n                return codePoint;\n              } else {\n                throw Error('Invalid continuation byte');\n              }\n            } // 4-byte sequence\n\n\n            if ((byte1 & 0xF8) == 0xF0) {\n              byte2 = readContinuationByte();\n              byte3 = readContinuationByte();\n              byte4 = readContinuationByte();\n              codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;\n\n              if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n                return codePoint;\n              }\n            }\n\n            throw Error('Invalid UTF-8 detected');\n          }\n\n          var byteArray;\n          var byteCount;\n          var byteIndex;\n\n          function utf8decode(byteString) {\n            byteArray = ucs2decode(byteString);\n            byteCount = byteArray.length;\n            byteIndex = 0;\n            var codePoints = [];\n            var tmp;\n\n            while ((tmp = decodeSymbol()) !== false) {\n              codePoints.push(tmp);\n            }\n\n            return ucs2encode(codePoints);\n          }\n          /*--------------------------------------------------------------------------*/\n\n          var utf8 = {\n            'version': '2.1.2',\n            'encode': utf8encode,\n            'decode': utf8decode\n          }; // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n\n          if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n              return utf8;\n            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n          } else { var key, hasOwnProperty, object; }\n        })(this);\n        /* WEBPACK VAR INJECTION */\n      }).call(this, __webpack_require__(10)(module), __webpack_require__(1));\n\n      /***/\n    },\n    /* 10 */\n    /***/function (module, exports) {\n\n      module.exports = function (module) {\n        if (!module.webpackPolyfill) {\n          module.deprecate = function () {};\n\n          module.paths = []; // module.parent = undefined by default\n\n          if (!module.children) module.children = [];\n          Object.defineProperty(module, \"loaded\", {\n            enumerable: true,\n            get: function get() {\n              return module.l;\n            }\n          });\n          Object.defineProperty(module, \"id\", {\n            enumerable: true,\n            get: function get() {\n              return module.i;\n            }\n          });\n          module.webpackPolyfill = 1;\n        }\n\n        return module;\n      };\n\n      /***/\n    },\n    /* 11 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      var types = __webpack_require__(2); // const STREAMING = 4294967295;\n\n      /**\r\n       * Read data for the given non-record variable\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @param {object} variable - Variable metadata\r\n       * @return {Array} - Data of the element\r\n       */\n\n      function nonRecord(buffer, variable) {\n        // variable type\n        var type = types.str2num(variable.type); // size of the data\n\n        var size = variable.size / types.num2bytes(type); // iterates over the data\n\n        var data = new Array(size);\n\n        for (var i = 0; i < size; i++) {\n          data[i] = types.readType(buffer, type, 1);\n        }\n\n        return data;\n      }\n      /**\r\n       * Read data for the given record variable\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @param {object} variable - Variable metadata\r\n       * @param {object} recordDimension - Record dimension metadata\r\n       * @return {Array} - Data of the element\r\n       */\n\n      function record(buffer, variable, recordDimension) {\n        // variable type\n        var type = types.str2num(variable.type);\n        var width = variable.size ? variable.size / types.num2bytes(type) : 1; // size of the data\n        // TODO streaming data\n\n        var size = recordDimension.length; // iterates over the data\n\n        var data = new Array(size);\n        var step = recordDimension.recordStep;\n\n        for (var i = 0; i < size; i++) {\n          var currentOffset = buffer.offset;\n          data[i] = types.readType(buffer, type, width);\n          buffer.seek(currentOffset + step);\n        }\n\n        return data;\n      }\n\n      module.exports.nonRecord = nonRecord;\n      module.exports.record = record;\n\n      /***/\n    },\n    /* 12 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      var utils = __webpack_require__(0);\n\n      var types = __webpack_require__(2); // Grammar constants\n\n\n      var ZERO = 0;\n      var NC_DIMENSION = 10;\n      var NC_VARIABLE = 11;\n      var NC_ATTRIBUTE = 12;\n      /**\r\n       * Read the header of the file\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @param {number} version - Version of the file\r\n       * @return {object} - Object with the fields:\r\n       *  * `recordDimension`: Number with the length of record dimension\r\n       *  * `dimensions`: List of dimensions\r\n       *  * `globalAttributes`: List of global attributes\r\n       *  * `variables`: List of variables\r\n       */\n\n      function header(buffer, version) {\n        // Length of record dimension\n        // sum of the varSize's of all the record variables.\n        var header = {\n          recordDimension: {\n            length: buffer.readUint32()\n          }\n        }; // Version\n\n        header.version = version; // List of dimensions\n\n        var dimList = dimensionsList(buffer);\n        header.recordDimension.id = dimList.recordId; // id of the unlimited dimension\n\n        header.recordDimension.name = dimList.recordName; // name of the unlimited dimension\n\n        header.dimensions = dimList.dimensions; // List of global attributes\n\n        header.globalAttributes = attributesList(buffer); // List of variables\n\n        var variables = variablesList(buffer, dimList.recordId, version);\n        header.variables = variables.variables;\n        header.recordDimension.recordStep = variables.recordStep;\n        return header;\n      }\n\n      var NC_UNLIMITED = 0;\n      /**\r\n       * List of dimensions\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @return {object} - Ojbect containing the following properties:\r\n       *  * `dimensions` that is an array of dimension object:\r\n        *  * `name`: String with the name of the dimension\r\n        *  * `size`: Number with the size of the dimension dimensions: dimensions\r\n       *  * `recordId`: the id of the dimension that has unlimited size or undefined,\r\n       *  * `recordName`: name of the dimension that has unlimited size\r\n       */\n\n      function dimensionsList(buffer) {\n        var recordId, recordName;\n        var dimList = buffer.readUint32();\n\n        if (dimList === ZERO) {\n          utils.notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of dimensions');\n          return [];\n        } else {\n          utils.notNetcdf(dimList !== NC_DIMENSION, 'wrong tag for list of dimensions'); // Length of dimensions\n\n          var dimensionSize = buffer.readUint32();\n          var dimensions = new Array(dimensionSize);\n\n          for (var dim = 0; dim < dimensionSize; dim++) {\n            // Read name\n            var name = utils.readName(buffer); // Read dimension size\n\n            var size = buffer.readUint32();\n\n            if (size === NC_UNLIMITED) {\n              // in netcdf 3 one field can be of size unlimmited\n              recordId = dim;\n              recordName = name;\n            }\n\n            dimensions[dim] = {\n              name: name,\n              size: size\n            };\n          }\n        }\n\n        return {\n          dimensions: dimensions,\n          recordId: recordId,\n          recordName: recordName\n        };\n      }\n      /**\r\n       * List of attributes\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @return {Array<object>} - List of attributes with:\r\n       *  * `name`: String with the name of the attribute\r\n       *  * `type`: String with the type of the attribute\r\n       *  * `value`: A number or string with the value of the attribute\r\n       */\n\n      function attributesList(buffer) {\n        var gAttList = buffer.readUint32();\n\n        if (gAttList === ZERO) {\n          utils.notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of attributes');\n          return [];\n        } else {\n          utils.notNetcdf(gAttList !== NC_ATTRIBUTE, 'wrong tag for list of attributes'); // Length of attributes\n\n          var attributeSize = buffer.readUint32();\n          var attributes = new Array(attributeSize);\n\n          for (var gAtt = 0; gAtt < attributeSize; gAtt++) {\n            // Read name\n            var name = utils.readName(buffer); // Read type\n\n            var type = buffer.readUint32();\n            utils.notNetcdf(type < 1 || type > 6, 'non valid type ' + type); // Read attribute\n\n            var size = buffer.readUint32();\n            var value = types.readType(buffer, type, size); // Apply padding\n\n            utils.padding(buffer);\n            attributes[gAtt] = {\n              name: name,\n              type: types.num2str(type),\n              value: value\n            };\n          }\n        }\n\n        return attributes;\n      }\n      /**\r\n       * List of variables\r\n       * @ignore\r\n       * @param {IOBuffer} buffer - Buffer for the file data\r\n       * @param {number} recordId - Id of the unlimited dimension (also called record dimension)\r\n       *                            This value may be undefined if there is no unlimited dimension\r\n       * @param {number} version - Version of the file\r\n       * @return {object} - Number of recordStep and list of variables with:\r\n       *  * `name`: String with the name of the variable\r\n       *  * `dimensions`: Array with the dimension IDs of the variable\r\n       *  * `attributes`: Array with the attributes of the variable\r\n       *  * `type`: String with the type of the variable\r\n       *  * `size`: Number with the size of the variable\r\n       *  * `offset`: Number with the offset where of the variable begins\r\n       *  * `record`: True if is a record variable, false otherwise (unlimited size)\r\n       */\n\n      function variablesList(buffer, recordId, version) {\n        var varList = buffer.readUint32();\n        var recordStep = 0;\n\n        if (varList === ZERO) {\n          utils.notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of variables');\n          return [];\n        } else {\n          utils.notNetcdf(varList !== NC_VARIABLE, 'wrong tag for list of variables'); // Length of variables\n\n          var variableSize = buffer.readUint32();\n          var variables = new Array(variableSize);\n\n          for (var v = 0; v < variableSize; v++) {\n            // Read name\n            var name = utils.readName(buffer); // Read dimensionality of the variable\n\n            var dimensionality = buffer.readUint32(); // Index into the list of dimensions\n\n            var dimensionsIds = new Array(dimensionality);\n\n            for (var dim = 0; dim < dimensionality; dim++) {\n              dimensionsIds[dim] = buffer.readUint32();\n            } // Read variables size\n\n\n            var attributes = attributesList(buffer); // Read type\n\n            var type = buffer.readUint32();\n            utils.notNetcdf(type < 1 && type > 6, 'non valid type ' + type); // Read variable size\n            // The 32-bit varSize field is not large enough to contain the size of variables that require\n            // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n\n            var varSize = buffer.readUint32(); // Read offset\n\n            var offset = buffer.readUint32();\n\n            if (version === 2) {\n              utils.notNetcdf(offset > 0, 'offsets larger than 4GB not supported');\n              offset = buffer.readUint32();\n            }\n\n            var record = false; // Count amount of record variables\n\n            if (typeof recordId !== 'undefined' && dimensionsIds[0] === recordId) {\n              recordStep += varSize;\n              record = true;\n            }\n\n            variables[v] = {\n              name: name,\n              dimensions: dimensionsIds,\n              attributes: attributes,\n              type: types.num2str(type),\n              size: varSize,\n              offset: offset,\n              record: record\n            };\n          }\n        }\n\n        return {\n          variables: variables,\n          recordStep: recordStep\n        };\n      }\n\n      module.exports = header;\n\n      /***/\n    },\n    /* 13 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      function toString() {\n        var result = [];\n        result.push('DIMENSIONS');\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.dimensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var dimension = _step.value;\n\n            result.push('  ' + dimension.name.padEnd(30) + ' = size: ' + dimension.size);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        result.push('');\n        result.push('GLOBAL ATTRIBUTES');\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.globalAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var attribute = _step2.value;\n\n            result.push('  ' + attribute.name.padEnd(30) + ' = ' + attribute.value);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        var variables = JSON.parse(JSON.stringify(this.variables));\n        result.push('');\n        result.push('VARIABLES:');\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = variables[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var variable = _step3.value;\n\n            variable.value = this.getDataVariable(variable);\n            var stringify = JSON.stringify(variable.value);\n            if (stringify.length > 50) stringify = stringify.substring(0, 50);\n\n            if (!isNaN(variable.value.length)) {\n              stringify += ' (length: ' + variable.value.length + ')';\n            }\n\n            result.push('  ' + variable.name.padEnd(30) + ' = ' + stringify);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return result.join('\\n');\n      }\n\n      module.exports = toString;\n\n      /***/\n    }]\n    /******/)\n  );\n});\n//# sourceMappingURL=netcdfjs.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./lib/netcdfjs.js?")},0:
/*!*************************************************************************************************************!*\
  !*** multi ./lib/jquery-2.1.1/jquery.min.js ./lib/Cesium/Sandcastle/Sandcastle-header.js ./lib/netcdfjs.js ***!
  \*************************************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ./lib/jquery-2.1.1/jquery.min.js */"./lib/jquery-2.1.1/jquery.min.js");\n__webpack_require__(/*! ./lib/Cesium/Sandcastle/Sandcastle-header.js */"./lib/Cesium/Sandcastle/Sandcastle-header.js");\nmodule.exports = __webpack_require__(/*! ./lib/netcdfjs.js */"./lib/netcdfjs.js");\n\n\n//# sourceURL=webpack:///multi_./lib/jquery-2.1.1/jquery.min.js_./lib/Cesium/Sandcastle/Sandcastle-header.js_./lib/netcdfjs.js?')}});